<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/play_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/play_mode.py" />
              <option name="originalContent" value="# python&#10;import random&#10;from pico2d import *&#10;import time&#10;&#10;import game_framework&#10;import game_world&#10;&#10;from duck import Duck&#10;from map import Background, Grass&#10;from gun import Gun&#10;from kamikaze import Kamikaze&#10;from scoreBoard import ScoreBoard&#10;import stage_choice_mode&#10;&#10;&#10;ducks = []&#10;kamikazes=[]&#10;gun = None&#10;grass = None&#10;scoreboard = None&#10;&#10;WAVE_SIZE=2 # 웨이브당 오리 수&#10;KAMIKAZE_PER_WAVE=1 # 웨이브당 자폭 오리 수&#10;&#10;def handle_events():&#10;    event_list = get_events()&#10;    for event in event_list:&#10;        if event.type == SDL_QUIT:&#10;            game_framework.quit()&#10;        elif event.type == SDL_KEYDOWN and event.key == SDLK_ESCAPE:&#10;            game_framework.quit()&#10;        else:&#10;            for duck in ducks:&#10;                duck.handle_event(event)  # Duck 인스턴스의 메서드 호출&#10;            if gun:&#10;                gun.handle_event(event)&#10;&#10;def spawn_wave():&#10;    # 점수 기준(300점 단위)을 넘었는지 확인하고, 넘었다면 다음 웨이브가 스폰되기 전에 속도 배수 적용 및 플레이어 선택 모드로 전환&#10;    increases = 0&#10;    try:&#10;        while game_world.score &gt;= game_world.next_speed_threshold:&#10;            game_world.speed_multiplier *= game_world.speed_increment_factor&#10;            game_world.next_speed_threshold += 300&#10;            increases += 1&#10;    except Exception:&#10;        increases = 0&#10;&#10;    if increases &gt; 0:&#10;        print(f'[play_mode] Applied speed increase x{increases}, multiplier={game_world.speed_multiplier:.3f}, next_threshold={game_world.next_speed_threshold}')&#10;        # 플레이어가 선택하도록 stage_choice_mode로 전환&#10;        try:&#10;            stage_choice_mode.pending_increases = increases&#10;            game_framework.push_mode(stage_choice_mode)&#10;        except Exception:&#10;            # 실패 시 폴백으로 자동 회복 적용&#10;            try:&#10;                if gun is not None:&#10;                    old_hp = gun.hp&#10;                    gun.hp = min(gun.max_hp, gun.hp + increases)&#10;                    print(f'[play_mode] (fallback) Gun HP restored {old_hp} -&gt; {gun.hp}')&#10;            except Exception:&#10;                pass&#10;        # 선택 모드에서 돌아올 때까지 웨이브 생성 중단&#10;        return&#10;&#10;    # 실제 웨이브 스폰&#10;    for _ in range(WAVE_SIZE):&#10;        duck = Duck()&#10;        ducks.append(duck)&#10;        game_world.add_object(duck, game_world.LAYER_FOREGROUND)&#10;    for _ in range(KAMIKAZE_PER_WAVE):&#10;        kamikaze = Kamikaze()&#10;        kamikazes.append(kamikaze)&#10;        game_world.add_object(kamikaze, game_world.LAYER_FOREGROUND)&#10;&#10;def init():&#10;    global ducks, gun, grass, kamikazes, scoreboard&#10;&#10;    # Background (레이어 0)&#10;    background = Background()&#10;    game_world.add_object(background, game_world.LAYER_BACKGROUND)&#10;&#10;    # Grass (레이어 2)&#10;    grass = Grass()&#10;    game_world.add_object(grass, game_world.LAYER_GRASS)&#10;&#10;    # Gun (레이어 3 / UI) — 플레이어는 먼저 생성되어야 함&#10;    gun = Gun()&#10;    game_world.add_object(gun, game_world.LAYER_UI)&#10;&#10;    # ScoreBoard (우측 상단) - UI 레이어&#10;    scoreboard = ScoreBoard()&#10;    game_world.add_object(scoreboard, game_world.LAYER_UI)&#10;&#10;    # 플레이 시작 시간 기록&#10;    try:&#10;        game_world.start_time = time.time()&#10;    except Exception:&#10;        game_world.start_time = None&#10;&#10;    # TESTING: 강제으로 선택 모드를 즉시 띄우기 위해 점수를 임계치로 설정 (테스트 후 제거 예정)&#10;    try:&#10;        game_world.score = game_world.next_speed_threshold&#10;    except Exception:&#10;        pass&#10;&#10;    # 오브젝트(오리/자폭) 스폰은 플레이어가 준비된 이후에 수행&#10;    spawn_wave()&#10;&#10;&#10;def update():&#10;    global ducks, kamikazes&#10;    game_world.update()&#10;&#10;    current_ducks=[o for o in game_world.world[game_world.LAYER_FOREGROUND] if isinstance(o,Duck)]&#10;    ducks=current_ducks&#10;&#10;    current_kamikazes = [o for o in game_world.world[game_world.LAYER_FOREGROUND] if isinstance(o, Kamikaze)]&#10;    kamikazes = current_kamikazes&#10;&#10;    if len(ducks) == 0 and len(kamikazes) == 0:&#10;        spawn_wave()&#10;&#10;def draw():&#10;    clear_canvas()&#10;    game_world.render()&#10;    update_canvas()&#10;&#10;&#10;def finish():&#10;    global gun, grass, scoreboard&#10;    game_world.clear()&#10;    ducks.clear()&#10;    kamikazes.clear()&#10;    gun = None&#10;    grass = None&#10;    scoreboard = None&#10;&#10;&#10;def pause(): pass&#10;def resume(): pass&#10;" />
              <option name="updatedContent" value="# python&#10;import random&#10;from pico2d import *&#10;import time&#10;&#10;import game_framework&#10;import game_world&#10;&#10;from duck import Duck&#10;from map import Background, Grass&#10;from gun import Gun&#10;from kamikaze import Kamikaze&#10;from scoreBoard import ScoreBoard&#10;import stage_choice_mode&#10;&#10;&#10;ducks = []&#10;kamikazes=[]&#10;gun = None&#10;grass = None&#10;scoreboard = None&#10;&#10;WAVE_SIZE=2 # 웨이브당 오리 수&#10;KAMIKAZE_PER_WAVE=1 # 웨이브당 자폭 오리 수&#10;&#10;def handle_events():&#10;    event_list = get_events()&#10;    for event in event_list:&#10;        if event.type == SDL_QUIT:&#10;            game_framework.quit()&#10;        elif event.type == SDL_KEYDOWN and event.key == SDLK_ESCAPE:&#10;            game_framework.quit()&#10;        else:&#10;            for duck in ducks:&#10;                duck.handle_event(event)  # Duck 인스턴스의 메서드 호출&#10;            if gun:&#10;                gun.handle_event(event)&#10;&#10;def spawn_wave():&#10;    # 점수 기준(300점 단위)을 넘었는지 확인하고, 넘었다면 다음 웨이브가 스폰되기 전에 속도 배수 적용 및 플레이어 선택 모드로 전환&#10;    increases = 0&#10;    try:&#10;        while game_world.score &gt;= game_world.next_speed_threshold:&#10;            game_world.speed_multiplier *= game_world.speed_increment_factor&#10;            game_world.next_speed_threshold += 300&#10;            increases += 1&#10;    except Exception:&#10;        increases = 0&#10;&#10;    if increases &gt; 0:&#10;        print(f'[play_mode] Applied speed increase x{increases}, multiplier={game_world.speed_multiplier:.3f}, next_threshold={game_world.next_speed_threshold}')&#10;        # 플레이어가 선택하도록 stage_choice_mode로 전환&#10;        try:&#10;            stage_choice_mode.pending_increases = increases&#10;            game_framework.push_mode(stage_choice_mode)&#10;        except Exception:&#10;            # 실패 시 폴백으로 자동 회복 적용&#10;            try:&#10;                if gun is not None:&#10;                    old_hp = gun.hp&#10;                    gun.hp = min(gun.max_hp, gun.hp + increases)&#10;                    print(f'[play_mode] (fallback) Gun HP restored {old_hp} -&gt; {gun.hp}')&#10;            except Exception:&#10;                pass&#10;        # 선택 모드에서 돌아올 때까지 웨이브 생성 중단&#10;        return&#10;&#10;    # 실제 웨이브 스폰&#10;    for _ in range(WAVE_SIZE):&#10;        duck = Duck()&#10;        ducks.append(duck)&#10;        game_world.add_object(duck, game_world.LAYER_FOREGROUND)&#10;    for _ in range(KAMIKAZE_PER_WAVE):&#10;        kamikaze = Kamikaze()&#10;        kamikazes.append(kamikaze)&#10;        game_world.add_object(kamikaze, game_world.LAYER_FOREGROUND)&#10;&#10;def init():&#10;    global ducks, gun, grass, kamikazes, scoreboard&#10;&#10;    # Background (레이어 0)&#10;    background = Background()&#10;    game_world.add_object(background, game_world.LAYER_BACKGROUND)&#10;&#10;    # Grass (레이어 2)&#10;    grass = Grass()&#10;    game_world.add_object(grass, game_world.LAYER_GRASS)&#10;&#10;    # Gun (레이어 3 / UI) — 플레이어는 먼저 생성되어야 함&#10;    gun = Gun()&#10;    game_world.add_object(gun, game_world.LAYER_UI)&#10;&#10;    # ScoreBoard (우측 상단) - UI 레이어&#10;    scoreboard = ScoreBoard()&#10;    game_world.add_object(scoreboard, game_world.LAYER_UI)&#10;&#10;    # 플레이 시작 시간 기록&#10;    try:&#10;        game_world.start_time = time.time()&#10;    except Exception:&#10;        game_world.start_time = None&#10;&#10;    # 오브젝트(오리/자폭) 스폰은 플레이어가 준비된 이후에 수행&#10;    spawn_wave()&#10;&#10;&#10;def update():&#10;    global ducks, kamikazes&#10;    game_world.update()&#10;&#10;    current_ducks=[o for o in game_world.world[game_world.LAYER_FOREGROUND] if isinstance(o,Duck)]&#10;    ducks=current_ducks&#10;&#10;    current_kamikazes = [o for o in game_world.world[game_world.LAYER_FOREGROUND] if isinstance(o, Kamikaze)]&#10;    kamikazes = current_kamikazes&#10;&#10;    if len(ducks) == 0 and len(kamikazes) == 0:&#10;        spawn_wave()&#10;&#10;def draw():&#10;    clear_canvas()&#10;    game_world.render()&#10;    update_canvas()&#10;&#10;&#10;def finish():&#10;    global gun, grass, scoreboard&#10;    game_world.clear()&#10;    ducks.clear()&#10;    kamikazes.clear()&#10;    gun = None&#10;    grass = None&#10;    scoreboard = None&#10;&#10;&#10;def pause(): pass&#10;def resume(): pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stage_choice_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stage_choice_mode.py" />
              <option name="originalContent" value="from pico2d import *&#10;import game_framework&#10;import game_world&#10;&#10;font = None&#10;pending_increases = 0  # play_mode에서 설정해서 전달&#10;_remaining = 0&#10;click_sound = None&#10;_overlay_drawn_logged = False&#10;&#10;def init():&#10;    global font, _remaining, pending_increases&#10;    print('[stage_choice_mode] init called, pending_increases =', pending_increases)&#10;    try:&#10;        if font is None:&#10;            font = load_font('ENCR10B.TTF', 28)&#10;    except Exception:&#10;        font = None&#10;&#10;    global click_sound&#10;    if click_sound is None:&#10;        try:&#10;            click_sound = load_wav('duckclick.mp3')&#10;            try:&#10;                click_sound.set_volume(1000)&#10;            except Exception:&#10;                pass&#10;        except Exception:&#10;            click_sound = None&#10;&#10;    _remaining = pending_increases&#10;    pending_increases = 0&#10;&#10;    # 안전장치: 증가가 없으면 즉시 되돌아감&#10;    if _remaining &lt;= 0:&#10;        game_framework.pop_mode()&#10;&#10;&#10;def handle_events():&#10;    global _remaining&#10;    events = get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == SDL_KEYDOWN:&#10;            if e.key == SDLK_1:&#10;                apply_choice('damage')&#10;            elif e.key == SDLK_2:&#10;                apply_choice('heal')&#10;            elif e.key == SDLK_ESCAPE:&#10;                game_framework.pop_mode()&#10;&#10;&#10;def find_gun():&#10;    try:&#10;        for o in game_world.world[game_world.LAYER_UI]:&#10;            if hasattr(o, 'hp') and hasattr(o, 'max_hp'):&#10;                return o&#10;    except Exception:&#10;        pass&#10;    return None&#10;&#10;&#10;def apply_choice(choice):&#10;    global _remaining&#10;    gun = find_gun()&#10;    if choice == 'damage':&#10;        if gun is not None:&#10;            try:&#10;                gun.damage = getattr(gun, 'damage', 1) + 1&#10;            except Exception:&#10;                pass&#10;    elif choice == 'heal':&#10;        if gun is not None:&#10;            try:&#10;                gun.hp = min(gun.max_hp, gun.hp + 1)&#10;            except Exception:&#10;                pass&#10;    # 클릭 사운드 재생&#10;    try:&#10;        if click_sound:&#10;            try:&#10;                click_sound.play()&#10;            except Exception:&#10;                pass&#10;    except Exception:&#10;        pass&#10;    _remaining -= 1&#10;    if _remaining &lt;= 0:&#10;        game_framework.pop_mode()&#10;&#10;&#10;def update():&#10;    pass&#10;&#10;&#10;def draw():&#10;    clear_canvas()&#10;    global _overlay_drawn_logged&#10;    print('[stage_choice_mode] draw called, _remaining =', _remaining)&#10;    w = get_canvas_width()&#10;    h = get_canvas_height()&#10;&#10;    # play_mode에서 사용하는 Background와 Grass를 그대로 그리기&#10;    try:&#10;        # Background 레이어 그리기&#10;        for o in list(game_world.world[game_world.LAYER_BACKGROUND]):&#10;            try:&#10;                o.draw()&#10;            except Exception:&#10;                pass&#10;        # Grass 레이어 그리기&#10;        for o in list(game_world.world[game_world.LAYER_GRASS]):&#10;            try:&#10;                o.draw()&#10;            except Exception:&#10;                pass&#10;    except Exception:&#10;        # game_world 구성이 아직 준비되지 않았으면 무시&#10;        pass&#10;&#10;    # 반투명 검은 오버레이로 배경을 어둡게 (가독성 향상)&#10;    print('[stage_choice_mode] overlay: about to draw overlay, w,h=', w, h)&#10;    try:&#10;        print('[stage_choice_mode] overlay: entering alpha path')&#10;        # 일부 pico2d 구현은 알파 블렌딩을 별도 활성화해야 함&#10;        try:&#10;            enable_alpha_blend(True)&#10;            print('[stage_choice_mode] overlay: enable_alpha_blend(True) succeeded')&#10;        except Exception as e:&#10;            print('[stage_choice_mode] overlay: enable_alpha_blend failed:', e)&#10;&#10;        # alpha가 지원되면 반투명으로 채움 (draw_line으로 채워 빈 공간 방지)&#10;        print('[stage_choice_mode] overlay: calling set_color with alpha')&#10;        set_color(0.0, 0.0, 0.0, 0.6)&#10;        print('[stage_choice_mode] overlay: set_color OK')&#10;        y = 0&#10;        while y &lt;= h:&#10;            draw_line(0, y, w, y)&#10;            y += 1&#10;&#10;        # 한 번만 로그 찍어 오버레이 경로가 실행됐는지 확인&#10;        if not _overlay_drawn_logged:&#10;            print('[stage_choice_mode] overlay drawn (alpha path)')&#10;            _overlay_drawn_logged = True&#10;&#10;        # 색상/blending 복구&#10;        set_color(1.0, 1.0, 1.0, 1.0)&#10;        try:&#10;            enable_alpha_blend(False)&#10;        except Exception:&#10;            pass&#10;&#10;    except Exception as e:&#10;        print('[stage_choice_mode] overlay: alpha path exception:', repr(e))&#10;        # alpha 경로 실패 시 불투명으로라도 채움&#10;        try:&#10;            print('[stage_choice_mode] overlay: entering opaque fallback')&#10;            set_color(0.0, 0.0, 0.0)&#10;            y = 0&#10;            while y &lt;= h:&#10;                draw_line(0, y, w, y)&#10;                y += 1&#10;            if not _overlay_drawn_logged:&#10;                print('[stage_choice_mode] overlay drawn (opaque fallback)')&#10;                _overlay_drawn_logged = True&#10;            set_color(1.0, 1.0, 1.0)&#10;        except Exception as e2:&#10;            print('[stage_choice_mode] overlay: opaque fallback exception:', repr(e2))&#10;            pass&#10;&#10;    # (배경 채우기 대신 텍스트만 오버레이)&#10;&#10;    title = &quot;Stage Up! Choose Upgrade&quot;&#10;    opt1 = &quot;1: Increase Gun Damage (+1)&quot;&#10;    opt2 = &quot;2: Restore 1 HP (up to max)&quot;&#10;    remain = f&quot;Remaining choices: {_remaining}&quot;&#10;&#10;    y = h // 2 + 60&#10;    if font:&#10;        font.draw(w//2 - 200, y, title, (255,255,255))&#10;        font.draw(w//2 - 200, y - 48, opt1, (200,200,255))&#10;        font.draw(w//2 - 200, y - 96, opt2, (200,255,200))&#10;        font.draw(w//2 - 200, y - 150, remain, (255,255,0))&#10;    else:&#10;        draw_rectangle(w//2 - 250, y + 20, w//2 + 250, y - 180)&#10;&#10;    update_canvas()&#10;&#10;&#10;def finish():&#10;    pass&#10;&#10;&#10;def pause():&#10;    pass&#10;&#10;&#10;def resume():&#10;    pass&#10;" />
              <option name="updatedContent" value="from pico2d import *&#10;import game_framework&#10;import game_world&#10;import os&#10;import base64&#10;&#10;font = None&#10;pending_increases = 0  # play_mode에서 설정해서 전달&#10;_remaining = 0&#10;click_sound = None&#10;_overlay_drawn_logged = False&#10;overlay_image = None&#10;&#10;def init():&#10;    global font, _remaining, pending_increases&#10;    try:&#10;        if font is None:&#10;            font = load_font('ENCR10B.TTF', 28)&#10;    except Exception:&#10;        font = None&#10;&#10;    global click_sound, overlay_image&#10;    if click_sound is None:&#10;        try:&#10;            click_sound = load_wav('duckclick.mp3')&#10;            try:&#10;                click_sound.set_volume(1000)&#10;            except Exception:&#10;                pass&#10;        except Exception:&#10;            click_sound = None&#10;&#10;    # Try loading a dedicated overlay image; if missing, create one from embedded base64&#10;    if overlay_image is None:&#10;        # prefer existing file&#10;        try:&#10;            if os.path.exists('overlay.png'):&#10;                overlay_image = load_image('overlay.png')&#10;            else:&#10;                # create overlay.png from embedded base64 (1x1 black pixel PNG)&#10;                b64 = (&#10;                    'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMA'&#10;                    'ASsJTYQAAAAASUVORK5CYII='&#10;                )&#10;                try:&#10;                    with open('overlay.png', 'wb') as f:&#10;                        f.write(base64.b64decode(b64))&#10;                    overlay_image = load_image('overlay.png')&#10;                except Exception:&#10;                    # fallback to demage.png if creation/loading fails&#10;                    try:&#10;                        overlay_image = load_image('demage.png')&#10;                    except Exception:&#10;                        overlay_image = None&#10;        except Exception:&#10;            try:&#10;                overlay_image = load_image('demage.png')&#10;            except Exception:&#10;                overlay_image = None&#10;&#10;    _remaining = pending_increases&#10;    pending_increases = 0&#10;&#10;    # 안전장치: 증가가 없으면 즉시 되돌아감&#10;    if _remaining &lt;= 0:&#10;        game_framework.pop_mode()&#10;&#10;&#10;def handle_events():&#10;    global _remaining&#10;    events = get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == SDL_KEYDOWN:&#10;            if e.key == SDLK_1:&#10;                apply_choice('damage')&#10;            elif e.key == SDLK_2:&#10;                apply_choice('heal')&#10;            elif e.key == SDLK_ESCAPE:&#10;                game_framework.pop_mode()&#10;&#10;&#10;def find_gun():&#10;    try:&#10;        for o in game_world.world[game_world.LAYER_UI]:&#10;            if hasattr(o, 'hp') and hasattr(o, 'max_hp'):&#10;                return o&#10;    except Exception:&#10;        pass&#10;    return None&#10;&#10;&#10;def apply_choice(choice):&#10;    global _remaining&#10;    gun = find_gun()&#10;    if choice == 'damage':&#10;        if gun is not None:&#10;            try:&#10;                gun.damage = getattr(gun, 'damage', 1) + 1&#10;            except Exception:&#10;                pass&#10;    elif choice == 'heal':&#10;        if gun is not None:&#10;            try:&#10;                gun.hp = min(gun.max_hp, gun.hp + 1)&#10;            except Exception:&#10;                pass&#10;    # 클릭 사운드 재생&#10;    try:&#10;        if click_sound:&#10;            try:&#10;                click_sound.play()&#10;            except Exception:&#10;                pass&#10;    except Exception:&#10;        pass&#10;    _remaining -= 1&#10;    if _remaining &lt;= 0:&#10;        game_framework.pop_mode()&#10;&#10;&#10;def update():&#10;    pass&#10;&#10;&#10;def draw():&#10;    clear_canvas()&#10;    global _overlay_drawn_logged&#10;    w = get_canvas_width()&#10;    h = get_canvas_height()&#10;&#10;    # play_mode에서 사용하는 Background와 Grass를 그대로 그리기&#10;    try:&#10;        # Background 레이어 그리기&#10;        for o in list(game_world.world[game_world.LAYER_BACKGROUND]):&#10;            try:&#10;                o.draw()&#10;            except Exception:&#10;                pass&#10;        # Grass 레이어 그리기&#10;        for o in list(game_world.world[game_world.LAYER_GRASS]):&#10;            try:&#10;                o.draw()&#10;            except Exception:&#10;                pass&#10;    except Exception:&#10;        # game_world 구성이 아직 준비되지 않았으면 무시&#10;        pass&#10;&#10;    # draw overlay image if available (covers screen, should have alpha)&#10;    try:&#10;        if overlay_image:&#10;            overlay_image.draw(w // 2, h // 2, w, h)&#10;    except Exception as e:&#10;        # failed to draw overlay image; ignore&#10;        print('[stage_choice_mode] overlay image draw failed:', repr(e))&#10;&#10;    # (배경 채우기 대신 텍스트만 오버레이)&#10;&#10;    title = &quot;Stage Up! Choose Upgrade&quot;&#10;    opt1 = &quot;1: Increase Gun Damage (+1)&quot;&#10;    opt2 = &quot;2: Restore 1 HP (up to max)&quot;&#10;    remain = f&quot;Remaining choices: {_remaining}&quot;&#10;&#10;    y = h // 2 + 60&#10;    if font:&#10;        font.draw(w//2 - 200, y, title, (255,255,255))&#10;        font.draw(w//2 - 200, y - 48, opt1, (200,200,255))&#10;        font.draw(w//2 - 200, y - 96, opt2, (200,255,200))&#10;        font.draw(w//2 - 200, y - 150, remain, (255,255,0))&#10;    else:&#10;        draw_rectangle(w//2 - 250, y + 20, w//2 + 250, y - 180)&#10;&#10;    update_canvas()&#10;&#10;&#10;def finish():&#10;    pass&#10;&#10;&#10;def pause():&#10;    pass&#10;&#10;&#10;def resume():&#10;    pass" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>